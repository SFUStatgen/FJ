---
title: "Get sequences and pool of cRVs to sample from"
output:
  pdf_document:
    number_sections: true
date: "2023-03-04"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction 

## R packages

* We require `SimRVSequences`, which is no longer on CRAN
and must be installed from GitHub. To install R packages
from GitHub you first need to install the `devtools` package, which *is*
available from CRAN.
* After installing `devtools`, cut-and-paste the following
command into your R console to install `SimRVSequences`.
(You only need to do this once.)

```{r,eval=FALSE}
devtools::install_github("https://github.com/simrvprojects/SimRVSequences")
```

## Data source

* We will use the sequence data that Nirodha simulated for
her *Data in Brief* paper. Below we provide a brief description of 
Nirodha's methods. Full details are in her Supplementary Materials 1-A document.
* Nirodha used the evolutionary simulation program `SLiM` to simulate 
whole-exome sequences from an American admixed population.
* `SLiM` users must specify a recombination map, a demographic model for the
source populations and the mutation model to use at each DNA nucleotide.
    * The recombination map for the exomes was generated by the function 
    `create_SlimMap()` from the `SimRVSequences` R package.
    * The demographic model is the "American Admixed" model in the `stdpopsim` 
    library of demographic models (https://github.com/popsim-consortium/stdpopsim).
    * The mutation model for nucleotides in the exome depends on the position of the nucleotide
    in a three-base-pair codon (units that code for an amino acid in 
    a protein). In particular, mutations at nucleotides in the first two 
    positions of a codon tend to change the amino acid. As changes to the amino acid tend to lead to worse survival outcomes, mutations in the first two positions of the codon
    were modeled to be under negative selection. By contrast, mutations at nucleotides
    in the third position of a codon tend not to change the amino acid 
    and so were modeled as selectively neutral.
* After simulating, Nirodha read the sequence data into R, filtered to only consider single-nucleotide variants (SNVs)
with population minor allele frequency (MAF) $<0.01$
and saved the results as an R object called "out" in a `Rdata` file `Chromwide.Rdata`. `Chromwide.Rdata` is available in the Zenodo repository at https://zenodo.org/record/6369360.

## Sequence data for our study

* We apply the filtering scheme in Christina's thesis to Nirodha's population data. 
* Christina used chromosome 8 sequences and sequence variants with population frequency less than $0.001$.

# Workflow 

## Read in Nirodha's SLiM output

```{r}
library(SimRVSequences)
load("Chromwide.Rdata")
```

* The above code chunk loads a list object called `out`, with one list element per 
chromosome.
* The list element for a given chromosome is itself a list with elements
`Haplotypes` and `Mutations`. 
    * `Haplotypes` is a sparse matrix of sequences, with two rows for 
    each individual in the population and columns for SNVs.
    * `Mutations` is a data frame with rows for SNVs and columns of
    information on the SNVs, such as the
    ID, chromosome, position, allele frequency, variant allele and
    selection coefficient.

## Extract chromosome 8

```{r}
chr8 <- out[[8]]
```


## Filter to SNVs with MAF < 0.001

* Identify SNVs with population MAF < 0.001. The column `afreq`
of the `Mutations` element of each chromosome gives the 
derived allele frequency in the population, 
which we use to subset the columns of `Haplotypes` and `Mutations`,

```{r}
library(Matrix) # for sparse matrix functions
keep <- chr8$Mutations$afreq < 0.001 | chr8$Mutations$afreq > 0.999
chr8 <- list(Haplotypes=chr8$Haplotypes[,keep],
              Mutations=chr8$Mutations[keep,])
```

## Determine cRVs from two apoptosis genes on chromosome 8

* The `sim_RVstudy()` function in Christina's `SimRVSequences` package drops genomes through the pedigree 
conditional on cRV status. The conditional gene drop requires 
a set of candidate cRVs from our population of variants. We need to select this set of cRVs and bundle the information on their locations 
with the R data object holding the population sequences. In particular, we need to add a logical vector
called `is_CRV` to the `Mutations` dataframe, with values `TRUE` for 
candidate cRVs and `FALSE` for all others.
* Christina's population of sequences was simulated with selectively-neutral DNA variants whereas Nirodha's was 
simulated with a mixture of neutral and negatively selected variants.
* Christina selected 9 rare SNVs to be cRVs from two genes on chr 8, TNFRSR10B and TNFRSF11B.
    * TNFRSR10B is at DNA base positions 23020133 to 23069031 and TNFRSF11B is at DNA base positions 118923557 to 118951885 on the human genome build GRCh38.p14 used by Christina.
* Christina chose cRVs to have roughly equal MAF and a cumulative MAF of no more than 0.001 in her population. She ended up with five rare variants (RVs), each with population MAF 0.0001, and four RVs, each with MAF 0.00011.
* Nirodha's simulated population has *no* RVs with frequency of about 0.0001, so we need to select our cRVs differently. 
    
* In her Data in Brief paper, Nirodha describes the following method for sampling cRVs:
    * Randomly sample singletons, in proportion to their selection coefficient,
from 25 genes in the apoptosis pathway, until their
cumulative population frequency is 0.001. 
* However, in our population with selection, the
two genes, TNFRSR10B and TNFRSF11B,
contain only six singleton RVs with non-zero selection coefficient. These six singleton RVs have a cumulative population frequency of 0.000057.
* We decided to instead sample 10 RVs from SNVs with 
minor allele count $\leq 10$ in the population,
in proportion to their selection coefficient. 
* This yielded four singletons, five doubletons and one tripleton with a cumulative minor allele frequency of 0.0001578 in the population. 

```{r}
# Extract the SNVs from the two TNF genes
posn <- chr8$Mutations$position
TNFmutns <- (posn >= 23020133 & posn <= 23069031) | # TNFRSR10B
            (posn >= 118923557 & posn <= 118951885) # TNFRSR11B
hh <- chr8$Haplotypes[,TNFmutns] #subset haplotypes to area of interest.
mm <- chr8$Mutations[TNFmutns,] #subset mutations to area of interest.
# Create a sampling weight vector for sampling RVs in propn to their 
# selection coefficient, stored in the selCoef column.
mm$weight <- abs(mm$selCoef)/sum(abs(mm$selCoef))
# Set a seed for reproducibility and sample RVs with population derived allele count <= 10 
# or >= (2*n-10) where n is the number of individuals in the population 
# (i.e. twice the number of rows of the dataframe hh)
set.seed(123)
cs <- colSums(hh)
ind <- (cs <= 10 | cs >= (2*nrow(hh) - 10)) 
ss <- sample((1:nrow(mm))[ind],size=10,prob = mm$weight[ind])
cRVinds <- sort(ss)
cRVschr8 <- mm[cRVinds,]
cat("selected cRVs have total probability:\n")
sum(cRVschr8[,"afreq"])
cat("selected cRVs are:\n")
cRVschr8[,c("position","afreq","selCoef","weight")] 
chr8$Mutations$is_CRV <- FALSE # initialize is_CRV col of mutations dataframe
setT <- chr8$Mutations$position %in% cRVschr8$position 
chr8$Mutations$is_CRV[setT] <- TRUE # set sampled cRVs to TRUE
```

## Save results

* Christina's gene drop function requires that the population of sequences be in
an object of class "SNVdata". We call the constructor for this class
and save the result in a .RData file for use in simulations.

```{r}
chr8 <- SNVdata(Haplotypes=chr8$Haplotypes,Mutations=chr8$Mutations)
save(chr8,file="chr8.RData")
```


## Generate the R script for the cluster

* The above R commands run on my laptop in less than 10 seconds, so it's not
really necessary to use the cluster. 
* However, if you prefer to run on the cluster, you can generate
the necessary R script by cut-and-pasting the following into your R console:

```{r}
knitr::purl(input="getseqscrvs.Rmd",output="getseqscrvs.R")
```

* Then delete the setup code chunk at the beginning of the resulting R script
and this `purl()` command at the end.
